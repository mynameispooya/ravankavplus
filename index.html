<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Psychoanalyst - روان‌کاو هوشمند</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Vazirmatn:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* استفاده از فونت‌های Inter برای انگلیسی و Vazirmatn برای فارسی */
        body {
            font-family: 'Inter', 'Vazirmatn', sans-serif;
            overscroll-behavior: none;
        }

        /* استایل سفارشی برای اسکرول‌بار چت */
        #chat-container::-webkit-scrollbar {
            width: 6px;
        }
        #chat-container::-webkit-scrollbar-thumb {
            background-color: #4b5563; /* gray-600 */
            border-radius: 20px;
        }
        #chat-container::-webkit-scrollbar-track {
            background-color: #1f2937; /* gray-800 */
        }

        /* کلاس برای مخفی کردن */
        .hidden {
            display: none !important;
        }
        
        /* انیمیشن برای نوتیفیکیشن بینش (Insight Toast) */
        @keyframes slideInUp {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        @keyframes slideOutDown {
            from {
                transform: translateY(0);
                opacity: 1;
            }
            to {
                transform: translateY(100%);
                opacity: 0;
            }
        }
        .toast-slide-in {
            animation: slideInUp 0.5s ease-out forwards;
        }
        .toast-slide-out {
            animation: slideOutDown 0.5s ease-in forwards;
        }

        .chat-bubble-button {
            @apply p-1.5 rounded-full text-gray-400 hover:text-gray-200 hover:bg-gray-700 transition-all duration-200;
        }
        
        /* استایل لودر اسپینر */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #ffffff;
            width: 24px;
            height: 24px;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* انیمیشن محو شدن */
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .animate-fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex items-center justify-center min-h-screen p-0 sm:p-4">

    <div id="api-key-screen" class="w-full max-w-md bg-gray-800 rounded-none sm:rounded-2xl shadow-2xl flex flex-col items-center p-6 sm:p-10 space-y-6 animate-fade-in h-screen sm:h-auto">
        <div class="w-16 h-16 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center shadow-lg">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-8 h-8 text-white">
                <path stroke-linecap="round" stroke-linejoin="round" d="M8.625 9.75a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm0 0H8.25m4.125 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm0 0H12m4.125 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm0 0h-.375m-13.5 3.01c0 1.6 1.123 2.994 2.707 3.227 1.087.16 2.185.283 3.293.369V21l4.184-4.183a1.14 1.14 0 0 1 .778-.332 48.294 48.294 0 0 0 5.83-.498c1.585-.233 2.708-1.626 2.708-3.228V6.741c0-1.602-1.123-2.995-2.707-3.228A48.394 48.394 0 0 0 12 3c-2.392 0-4.744.175-7.043.513C3.373 3.746 2.25 5.14 2.25 6.741v6.018Z" />
            </svg>
        </div>
        
        <h1 class="text-3xl font-bold text-center text-white">روان‌کاو هوشمند</h1>
        <p class="text-center text-gray-300 text-base">
            برای شروع، لطفاً Gemini API Key خود را وارد کنید.
        </p>
        
        <div class="w-full space-y-2 pt-4">
            <label for="api-key-input" class="block text-sm font-medium text-gray-300 px-1">Gemini API Key</label>
            <input type="password" id="api-key-input" class="w-full px-4 py-3 bg-gray-900 border border-gray-700 rounded-lg text-left text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="AIza..." dir="ltr">
        </div>
        
        <button id="api-key-submit" class="w-full px-4 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-0.5">
            شروع
        </button>
        
        <p class="text-xs text-gray-500 text-center" dir="ltr">
            Your API key is stored only in your browser.
        </p>
    </div>

    <div id="topic-screen" class="w-full max-w-lg bg-gray-800 rounded-none sm:rounded-2xl shadow-2xl flex flex-col p-6 sm:p-10 space-y-6 animate-fade-in h-screen sm:h-auto hidden">
        <h1 class="text-3xl font-bold text-center text-white">موضوع جلسه</h1>
        <p class="text-center text-gray-300">
            لطفاً موضوع اصلی که می‌خواهید در مورد آن صحبت کنید را وارد کنید (فارسی یا انگلیسی).
            <br>
            هوش مصنوعی بر اساس این موضوع، نقش روان‌کاو مناسب را انتخاب خواهد کرد.
        </p>
        <div class="space-y-2">
            <label for="topic-input" class="block text-sm font-medium text-gray-300">موضوع (Topic)</label>
            <input type="text" id="topic-input" class="w-full px-4 py-3 bg-gray-900 border border-gray-700 rounded-lg text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="مثال: مدیریت استرس، روابط عاطفی، اهمال‌کاری و...">
        </div>
        <button id="topic-submit" class="w-full px-4 py-3 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-0.5 flex items-center justify-center space-x-2 space-x-reverse">
            <span id="topic-submit-text">شروع جلسه و تعیین نقش</span>
            <div id="topic-loader" class="spinner hidden"></div>
        </button>
        <div class="relative pt-4">
            <div class="absolute inset-0 flex items-center" aria-hidden="true">
                <div class="w-full border-t border-gray-700"></div>
            </div>
            <div class="relative flex justify-center">
                <span class="bg-gray-800 px-3 text-sm text-gray-400">یا</span>
            </div>
        </div>
        <label for="import-input" class="w-full text-center cursor-pointer px-4 py-3 bg-gray-700 hover:bg-gray-600 text-white font-medium rounded-lg transition duration-200">
            بارگذاری جلسه قبلی (.json)
            <input type="file" id="import-input" class="hidden" accept=".json">
        </label>
    </div>

    <div id="main-chat-screen" class="w-full h-screen sm:h-[95vh] sm:max-w-7xl bg-gray-800 rounded-none sm:rounded-2xl shadow-2xl flex flex-col hidden overflow-hidden">
        
        <header class="flex-shrink-0 p-4 bg-gray-900/50 backdrop-blur-sm border-b border-gray-700 flex items-center justify-between z-30">
            <div class="flex items-center space-x-3 space-x-reverse">
                <div class="w-3 h-3 bg-green-400 rounded-full animate-pulse"></div>
                <h1 class="text-lg font-bold text-white">
                    در حال صحبت با: <span id="persona-name-display" class="text-yellow-400">...</span>
                </h1>
            </div>
            <div class="flex items-center space-x-2 space-x-reverse">
                <button id="export-button" class="px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-semibold rounded-lg transition duration-200 flex items-center space-x-1 space-x-reverse">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>
                    <span class="hidden sm:inline">ذخیره جلسه</span>
                </button>
                <button id="toggle-insights-btn" class="px-3 py-2 bg-purple-600 hover:bg-purple-700 text-white text-sm font-semibold rounded-lg transition duration-200 flex items-center space-x-1 space-x-reverse md:hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-1.125m-1.5 1.125a6.01 6.01 0 0 1-1.5-1.125m1.5 1.125v-1.5A2.25 2.25 0 0 1 13.5 9.75h.5a2.25 2.25 0 0 1 2.25 2.25v1.5m-3 0h3m-3 0h-1.5a2.25 2.25 0 0 0-2.25 2.25v1.5A2.25 2.25 0 0 0 9.75 18h4.5A2.25 2.25 0 0 0 16.5 15.75v-1.5a2.25 2.25 0 0 0-2.25-2.25h-.5A2.25 2.25 0 0 0 12 9.75v1.5m0 0v-1.5m0 1.5v5.25m0 0v-5.25" /></svg>
                    <span class="hidden sm:inline">بینش‌ها</span>
                </button>
            </div>
        </header>

        <div class="flex-grow flex h-full overflow-hidden relative">
            
            <aside id="insights-sidebar" class="w-full md:w-1/3 lg:w-1/4 flex-shrink-0 bg-gray-800/95 md:bg-gray-800 backdrop-blur-sm md:backdrop-blur-none border-l border-gray-700 p-4 flex-col md:flex absolute md:relative h-full z-20 -translate-x-full md:translate-x-0 transition-transform duration-300 ease-in-out">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-bold text-white">بینش‌های جلسه</h2>
                    <button id="close-insights-btn" class="p-1 rounded-full text-gray-300 hover:bg-gray-700 md:hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" /></svg>
                    </button>
                </div>
                <div id="insights-container" class="flex-grow overflow-y-auto space-y-3 pr-2">
                    <p class="text-gray-400 text-sm">هنوز بینشی استخراج نشده است. در طول گفتگو، نکات کلیدی در اینجا ظاهر می‌شوند.</p>
                </div>
            </aside>

            <main class="flex-grow flex flex-col h-full overflow-hidden">
                <div id="chat-container" class="flex-grow p-4 sm:p-6 space-y-6 overflow-y-auto">
                    </div>

                <footer class="flex-shrink-0 p-4 bg-gray-900/50 backdrop-blur-sm border-t border-gray-700 z-10">
                    <div class="flex items-start space-x-3 space-x-reverse">
                        <textarea id="message-input"
                            class="flex-grow w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-xl text-gray-100 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
                            placeholder="پیام خود را تایپ کنید... (Shift + Enter برای خط جدید)"
                            rows="1"
                            style="min-height: 52px; max-height: 200px;"></textarea>
                        
                        <button id="send-button" class="w-12 h-12 flex-shrink-0 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-xl shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-0.5 flex items-center justify-center">
                            <span id="send-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M6 12 3.269 3.125A59.769 59.769 0 0 1 21.485 12 59.768 59.768 0 0 1 3.27 20.875L6 12Z" /></svg>
                            </span>
                            <div id="chat-loader" class="spinner hidden"></div>
                        </button>
                    </div>
                </footer>
            </main>

        </div>
    </div>

    <div id="loading-overlay" class="fixed inset-0 bg-gray-900/80 backdrop-blur-md flex items-center justify-center z-50 hidden">
        <div class="flex flex-col items-center space-y-4">
            <div class="spinner !w-16 !h-16 !border-4"></div>
            <p id="loading-text" class="text-xl font-semibold text-white">در حال تعیین نقش روان‌کاو...</p>
        </div>
    </div>

    <div id="insight-toast" class="fixed bottom-6 right-1/2 translate-x-1/2 sm:translate-x-0 sm:right-6 w-[90vw] max-w-sm bg-purple-600 text-white p-4 rounded-lg shadow-2xl z-40 hidden" style="transform: translateY(150%);">
        <div class="flex items-start space-x-3 space-x-reverse">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6 flex-shrink-0"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-1.125m-1.5 1.125a6.01 6.01 0 0 1-1.5-1.125m1.5 1.125v-1.5A2.25 2.25 0 0 1 13.5 9.75h.5a2.25 2.25 0 0 1 2.25 2.25v1.5m-3 0h3m-3 0h-1.5a2.25 2.25 0 0 0-2.25 2.25v1.5A2.25 2.25 0 0 0 9.75 18h4.5A2.25 2.25 0 0 0 16.5 15.75v-1.5a2.25 2.25 0 0 0-2.25-2.25h-.5A2.25 2.25 0 0 0 12 9.75v1.5m0 0v-1.5m0 1.5v5.25m0 0v-5.25" /></svg>
            <div>
                <h3 class="font-bold">بینش جدید!</h3>
                <p id="insight-toast-text" class="text-sm"></p>
            </div>
            <button id="insight-toast-close" class="ml-auto p-1 -m-1 rounded-full hover:bg-purple-700">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" /></svg>
            </button>
        </div>
    </div>


    <script type="module">
        // -------------------------------------------
        // State Management (مدیریت وضعیت برنامه)
        // -------------------------------------------
        let apiKey = localStorage.getItem('gemini_api_key') || '';
        let chatHistory = []; // تاریخچه کامل چت برای ارسال به Gemini
        let insights = []; // لیست بینش‌های استخراج شده
        let currentPersona = ''; // نام نقش (مثل جردن پیترسون)
        let systemPrompt = ''; // پرامپت سیستمی برای نقش
        let audioContext = null; // برای پخش صدای TTS
        let currentPlayingAudio = null; // برای متوقف کردن صدای قبلی
        
        let messageStates = {}; 

        // -------------------------------------------
        // Element Selectors (انتخاب المان‌های DOM)
        // -------------------------------------------
        const $ = (selector) => document.querySelector(selector);
        
        const screens = {
            apiKey: $('#api-key-screen'),
            topic: $('#topic-screen'),
            mainChat: $('#main-chat-screen'),
        };
        
        const elements = {
            apiKeyInput: $('#api-key-input'),
            apiKeySubmit: $('#api-key-submit'),
            topicInput: $('#topic-input'),
            topicSubmit: $('#topic-submit'),
            topicSubmitText: $('#topic-submit-text'),
            topicLoader: $('#topic-loader'),
            importInput: $('#import-input'),
            exportButton: $('#export-button'),
            personaNameDisplay: $('#persona-name-display'),
            chatContainer: $('#chat-container'),
            insightsContainer: $('#insights-container'),
            messageInput: $('#message-input'),
            sendButton: $('#send-button'),
            sendIcon: $('#send-icon'),
            chatLoader: $('#chat-loader'),
            loadingOverlay: $('#loading-overlay'),
            loadingText: $('#loading-text'),
            insightToast: $('#insight-toast'),
            insightToastText: $('#insight-toast-text'),
            insightToastClose: $('#insight-toast-close'),
            insightsSidebar: $('#insights-sidebar'),
            toggleInsightsBtn: $('#toggle-insights-btn'),
            closeInsightsBtn: $('#close-insights-btn'),
        };

        // -------------------------------------------
        // Initial Setup (راه‌اندازی اولیه)
        // -------------------------------------------
        document.addEventListener('DOMContentLoaded', () => {
            if (apiKey) {
                elements.apiKeyInput.value = apiKey;
                switchScreen('topic');
            } else {
                switchScreen('apiKey');
            }
            setupAudioContext();
            setupEventListeners();
            autoResizeTextarea(elements.messageInput);
        });

        function setupAudioContext() {
            if (audioContext) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') {
                    const resumeAudio = () => {
                        audioContext.resume();
                        document.body.removeEventListener('click', resumeAudio);
                        document.body.removeEventListener('touchstart', resumeAudio);
                    };
                    document.body.addEventListener('click', resumeAudio);
                    document.body.addEventListener('touchstart', resumeAudio);
                }
            } catch (e) {
                console.error("Web Audio API is not supported in this browser.", e);
            }
        }
        
        // -------------------------------------------
        // Event Listeners (ثبت شنونده‌های رویداد)
        // -------------------------------------------
        function setupEventListeners() {
            elements.apiKeySubmit.addEventListener('click', handleApiKeySubmit);
            elements.topicSubmit.addEventListener('click', handleTopicSubmit);
            elements.sendButton.addEventListener('click', handleSendMessage);
            elements.messageInput.addEventListener('keydown', handleTextareaKeydown);
            elements.exportButton.addEventListener('click', handleExportSession);
            elements.importInput.addEventListener('change', handleImportSession);
            elements.insightToastClose.addEventListener('click', hideInsightToast);
            elements.toggleInsightsBtn.addEventListener('click', () => {
                elements.insightsSidebar.classList.remove('-translate-x-full');
            });
            elements.closeInsightsBtn.addEventListener('click', () => {
                elements.insightsSidebar.classList.add('-translate-x-full');
            });
            elements.chatContainer.addEventListener('click', handleChatBubbleClicks);
        }
        
        // -------------------------------------------
        // Screen & UI Management (مدیریت صفحات و UI)
        // -------------------------------------------
        
        function switchScreen(screenName) {
            Object.values(screens).forEach(screen => screen.classList.add('hidden'));
            if (screens[screenName]) {
                screens[screenName].classList.remove('hidden');
                if (screenName === 'apiKey' || screenName === 'topic') {
                    screens[screenName].classList.add('flex', 'flex-col');
                } else if (screenName === 'mainChat') {
                     screens[screenName].classList.add('flex', 'flex-col');
                }
            }
        }
        
        function autoResizeTextarea(textarea) {
            const adjustHeight = () => {
                textarea.style.height = 'auto';
                textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`;
            };
            textarea.addEventListener('input', adjustHeight);
            adjustHeight();
        }
        
        function showLoading(button, loader, textElement = null, text = '') {
            if (button) button.disabled = true;
            if (loader) loader.classList.remove('hidden');
            if (textElement && text) textElement.textContent = text;
            if(button === elements.sendButton) elements.sendIcon.classList.add('hidden');
        }

        function hideLoading(button, loader, textElement = null, text = '') {
            if (button) button.disabled = false;
            if (loader) loader.classList.add('hidden');
            if (textElement && text) textElement.textContent = text;
            if(button === elements.sendButton) elements.sendIcon.classList.remove('hidden');
        }

        function showButtonLoading(button, loader, iconContainer) {
            button.disabled = true;
            loader.classList.remove('hidden');
            if (iconContainer) iconContainer.classList.add('hidden');
        }

        function hideButtonLoading(button, loader, iconContainer) {
            button.disabled = false;
            loader.classList.add('hidden');
            if (iconContainer) iconContainer.classList.remove('hidden');
        }
        
        function showError(message) {
            console.error(message);
            alert(`خطا: ${message}`);
        }
        
        function showInsightToast(text) {
            elements.insightToastText.textContent = text;
            elements.insightToast.classList.remove('hidden', 'toast-slide-out');
            elements.insightToast.classList.add('toast-slide-in');
            setTimeout(hideInsightToast, 6000);
        }

        function hideInsightToast() {
            elements.insightToast.classList.remove('toast-slide-in');
            elements.insightToast.classList.add('toast-slide-out');
            setTimeout(() => {
                elements.insightToast.classList.add('hidden');
            }, 500);
        }

        // -------------------------------------------
        // Core Handlers (کنترل‌کننده‌های اصلی)
        // -------------------------------------------

        function handleApiKeySubmit() {
            setupAudioContext();
            const key = elements.apiKeyInput.value.trim();
            if (key) {
                apiKey = key;
                localStorage.setItem('gemini_api_key', key);
                switchScreen('topic');
            } else {
                showError("API Key نمی‌تواند خالی باشد.");
            }
        }

        async function handleTopicSubmit() {
            const topic = elements.topicInput.value.trim();
            if (!topic) {
                showError("لطفاً یک موضوع وارد کنید.");
                return;
            }

            showLoading(elements.topicSubmit, elements.topicLoader, elements.topicSubmitText, "در حال پردازش...");
            elements.loadingOverlay.classList.remove('hidden');
            elements.loadingText.textContent = "در حال تعیین نقش روان‌کاو...";

            try {
                const personaData = await generatePersona(topic);
                currentPersona = personaData.personaName;
                systemPrompt = personaData.systemPrompt;
                
                elements.personaNameDisplay.textContent = currentPersona;
                
                const greetingMessage = {
                    id: crypto.randomUUID(),
                    role: 'model',
                    text: personaData.greeting,
                };
                
                chatHistory.push({ role: 'model', parts: [{ text: greetingMessage.text }] });
                
                messageStates[greetingMessage.id] = {
                    text: greetingMessage.text,
                    originalLang: 'en',
                    translatedFa: null,
                    translatedEn: null
                };

                renderMessage(greetingMessage);
                switchScreen('mainChat');
                
            } catch (error) {
                console.error("Error generating persona:", error);
                showError(`خطا در تعیین نقش: ${error.message}. لطفاً API Key و اتصال خود را بررسی کنید.`);
            } finally {
                hideLoading(elements.topicSubmit, elements.topicLoader, elements.topicSubmitText, "شروع جلسه و تعیین نقش");
                elements.loadingOverlay.classList.add('hidden');
            }
        }

        function handleTextareaKeydown(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSendMessage();
            }
        }

        async function handleSendMessage() {
            const userText = elements.messageInput.value.trim();
            if (!userText) return;

            showLoading(elements.sendButton, elements.chatLoader);
            elements.messageInput.value = '';
            elements.messageInput.style.height = 'auto';

            const userMessage = {
                id: crypto.randomUUID(),
                role: 'user',
                text: userText,
            };
            chatHistory.push({ role: 'user', parts: [{ text: userText }] });
            renderMessage(userMessage);

            try {
                await processModelResponse(userText);
            } catch (error) {
                console.error("Error in chat pipeline:", error);
                showError(`خطا در دریافت پاسخ: ${error.message}`);
                chatHistory.pop(); 
                renderErrorMessage("متاسفانه پاسخی دریافت نشد. لطفاً دوباره تلاش کنید.");
            } finally {
                hideLoading(elements.sendButton, elements.chatLoader);
            }
        }
        
        /**
         * منطق پردازش پاسخ مدل، برای استفاده در ارسال و بازتولید
         */
        async function processModelResponse(userText) {
            // مخفی کردن دکمه‌های بازتولید قدیمی
            document.querySelectorAll('.regenerate-button').forEach(btn => btn.classList.add('hidden'));

            const [modelResponse, insight] = await Promise.all([
                getGeminiResponse(),
                getInsight(userText)
            ]);

            const modelMessage = {
                id: crypto.randomUUID(),
                role: 'model',
                text: modelResponse,
            };
            chatHistory.push({ role: 'model', parts: [{ text: modelResponse }] });
            
            const responseLang = isFarsi(modelResponse) ? 'fa' : 'en';
            messageStates[modelMessage.id] = {
                text: modelResponse,
                originalLang: responseLang,
                translatedFa: (responseLang === 'fa') ? modelResponse : null,
                translatedEn: (responseLang === 'en') ? modelResponse : null
            };
            
            renderMessage(modelMessage);

            if (insight && insight !== 'NO_INSIGHT' && insight.length > 10) {
                insights.push(insight);
                renderNewInsight(insight);
                showInsightToast(insight);
            }
        }

        async function handleChatBubbleClicks(e) {
            const button = e.target.closest('button');
            if (!button) return;
            
            const messageId = button.dataset.messageId;
            const action = button.dataset.action;
            const messageEl = $(`#msg-${messageId}`);
            if (!messageEl) return;
            
            const textEl = messageEl.querySelector('.message-content');
            
            // --- مدیریت ترجمه ---
            if (action === 'translate-fa' || action === 'translate-en' || action === 'untranslate') {
                const state = messageStates[messageId];
                if (!state) return;

                const loader = button.querySelector('.spinner');
                const iconContainer = button.querySelector('.translate-icon-container');
                
                showButtonLoading(button, loader, iconContainer);

                try {
                    if (action === 'translate-fa') {
                        if (!state.translatedFa) {
                            state.translatedFa = await getTranslation(state.text, 'en-to-fa');
                        }
                        textEl.textContent = state.translatedFa;
                        textEl.dir = 'rtl';
                        button.dataset.action = 'untranslate';
                        iconContainer.innerHTML = getTranslateButtonIcon('en');
                    
                    } else if (action === 'translate-en') {
                        if (!state.translatedEn) {
                            state.translatedEn = await getTranslation(state.text, 'fa-to-en');
                        }
                        textEl.textContent = state.translatedEn;
                        textEl.dir = 'ltr';
                        button.dataset.action = 'untranslate';
                        iconContainer.innerHTML = getTranslateButtonIcon('fa');
                    
                    } else if (action === 'untranslate') {
                        textEl.textContent = state.text;
                        if (state.originalLang === 'fa') {
                            textEl.dir = 'rtl';
                            button.dataset.action = 'translate-en';
                            iconContainer.innerHTML = getTranslateButtonIcon('en');
                        } else {
                            textEl.dir = 'ltr';
                            button.dataset.action = 'translate-fa';
                            iconContainer.innerHTML = getTranslateButtonIcon('fa');
                        }
                    }
                } catch (error) {
                    showError("خطا در ترجمه متن.");
                    console.error(error);
                    const originalAction = (state.originalLang === 'fa') ? 'translate-en' : 'translate-fa';
                    const originalIcon = (state.originalLang === 'fa') ? 'en' : 'fa';
                    button.dataset.action = originalAction;
                    iconContainer.innerHTML = getTranslateButtonIcon(originalIcon);
                } finally {
                    hideButtonLoading(button, loader, iconContainer);
                }
            }
            
            // --- مدیریت TTS ---
            else if (action === 'tts') {
                const textToSpeak = textEl.textContent;
                const loader = button.querySelector('.spinner');
                const ttsIcon = button.querySelector('.tts-icon');
                const ttsStopIcon = button.querySelector('.tts-stop-icon');
                
                if (currentPlayingAudio && currentPlayingAudio.buttonId === messageId) {
                    currentPlayingAudio.audio.pause();
                    currentPlayingAudio.audio.currentTime = 0;
                    currentPlayingAudio = null;
                    ttsIcon.classList.remove('hidden');
                    ttsStopIcon.classList.add('hidden');
                    return;
                } else if (currentPlayingAudio) {
                    currentPlayingAudio.audio.pause();
                    const prevButton = $(`#msg-${currentPlayingAudio.buttonId} button[data-action='tts']`);
                    if (prevButton) {
                        prevButton.querySelector('.tts-icon').classList.remove('hidden');
                        prevButton.querySelector('.tts-stop-icon').classList.add('hidden');
                    }
                }

                showButtonLoading(button, loader, ttsIcon);
                
                try {
                    const audio = await getAndPlayTTS(textToSpeak, messageId);
                    
                    loader.classList.add('hidden');
                    ttsIcon.classList.add('hidden');
                    ttsStopIcon.classList.remove('hidden');
                    button.disabled = false;

                    audio.onended = () => {
                        ttsIcon.classList.remove('hidden');
                        ttsStopIcon.classList.add('hidden');
                        currentPlayingAudio = null;
                    };
                    
                } catch (error) {
                    showError("خطا در پخش صدا.");
                    console.error(error);
                    hideButtonLoading(button, loader, ttsIcon);
                }
            }
            
            // --- مدیریت کپی ---
            else if (action === 'copy') {
                handleCopyClick(button, textEl);
            }
            
            // --- مدیریت بازتولید ---
            else if (action === 'regenerate') {
                handleRegenerateClick(button, messageId, messageEl);
            }
        }
        
        /**
         * منطق کلیک دکمه کپی
         */
        async function handleCopyClick(button, textEl) {
            const textToCopy = textEl.textContent;
            try {
                const textArea = document.createElement("textarea");
                textArea.value = textToCopy;
                textArea.style.position = "fixed"; 
                textArea.style.top = 0;
                textArea.style.left = 0;
                textArea.style.opacity = 0;
                document.body.appendChild(textArea);
                
                textArea.focus();
                textArea.select();
                
                document.execCommand('copy');
                
                document.body.removeChild(textArea);

                const iconContainer = button.querySelector('.copy-icon-container');
                const originalIconHTML = iconContainer.innerHTML;
                iconContainer.innerHTML = getCopyButtonIcon('copied'); 
                
                setTimeout(() => {
                    iconContainer.innerHTML = originalIconHTML; 
                }, 2000);

            } catch (err) {
                console.error('Failed to copy text: ', err);
                showError('خطا در کپی کردن متن.');
            }
        }
        
        /**
         * منطق کلیک دکمه بازتولید
         */
        async function handleRegenerateClick(button, messageId, messageEl) {
            if (chatHistory[chatHistory.length - 1].role !== 'model' || 
                chatHistory[chatHistory.length - 1].parts[0].text !== messageStates[messageId]?.text) {
                console.warn("Regenerate called on non-last message.");
                button.classList.add('hidden'); 
                return;
            }

            const loader = button.querySelector('.spinner');
            const iconContainer = button.querySelector('.regenerate-icon-container');
            
            showButtonLoading(button, loader, iconContainer);
            showLoading(elements.sendButton, elements.chatLoader);
            
            try {
                messageEl.remove();
                delete messageStates[messageId];
                chatHistory.pop(); 

                const lastUserText = chatHistory[chatHistory.length - 1].parts[0].text;

                await processModelResponse(lastUserText);

            } catch (error) {
                console.error("Error regenerating response:", error);
                showError("خطا در بازتولید پاسخ.");
            } finally {
                hideLoading(elements.sendButton, elements.chatLoader);
            }
        }
        
        // -------------------------------------------
        // Gemini API Calls (فراخوانی‌های Gemini)
        // -------------------------------------------
        
        async function callGeminiApi(model, payload, retries = 3, delay = 1000) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error("API Error Response:", errorData);
                        if (response.status === 429) { 
                            await new Promise(res => setTimeout(res, delay * Math.pow(2, i)));
                            continue;
                        }
                        throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    if (result.candidates?.[0]?.finishReason === 'SAFETY') {
                        throw new Error("پاسخ به دلیل محدودیت‌های ایمنی بلاک شد.");
                    }
                    if (result.candidates?.[0]?.finishReason === 'RECITATION') {
                         throw new Error("پاسخ به دلیل محدودیت‌های استنادی بلاک شد.");
                    }
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) {
                        if (result.candidates?.[0]?.finishReason === 'STOP' && result.candidates?.[0]?.content?.parts) {
                            return ""; // پاسخ خالی اما موفق
                        }
                        console.warn("Unexpected API response structure:", result);
                        throw new Error("پاسخ دریافتی ساختار معتبری نداشت.");
                    }
                    
                    return result;

                } catch (error) {
                    console.error(`Attempt ${i + 1} failed:`, error.message);
                    if (i === retries - 1) throw error;
                    if (error.message.includes('Rate limit exceeded')) {
                         await new Promise(res => setTimeout(res, delay * Math.pow(2, i)));
                    }
                }
            }
            throw new Error("عملیات پس از چند تلاش ناموفق بود.");
        }

        /**
         * ۱. تعیین نقش (Persona)
         */
        async function generatePersona(topic) {
            const personaSystemPrompt = `You are a 'Persona Router'. A user will provide a topic. Your job is to select the *single* most relevant expert persona from this list: Dr. Andrew Huberman (neuroscience, performance, focus, sleep), Dr. Jordan Peterson (philosophy, life rules, responsibility, meaning), Esther Perel (relationships, intimacy, infidelity, couples), Dr. Gabor Maté (trauma, addiction, stress, childhood development), Brené Brown (vulnerability, shame, courage, leadership), Dr. Nicole LePera (holistic psychology, self-healing, boundaries, inner child), or 'Compassionate Therapist' (for general support, active listening, or topics not covered by others).
            You MUST respond *only* with a JSON object. The JSON must have three keys:
            1.  "personaName": (string) The full name of the chosen persona (e.g., "Dr. Andrew Huberman").
            2.  "greeting": (string) The persona's first greeting message, in English, related to their expertise and the user's topic.
            3.  "systemPrompt": (string) A detailed system instruction for the *main* chat AI. This prompt is critical. It must follow these 4 rules:
                1.  **Think like the persona:** Embody their core expertise, insights, and perspectives (e.g., Huberman's on neuroscience tools, Gabor Maté's on trauma).
                2.  **Speak with a new style:** DO NOT imitate their academic or complex speaking style. Your communication style MUST be simple, warm, friendly, and empathetic. Avoid all academic jargon. Speak like a kind and knowledgeable guide, not a lecturer.
                3.  **Detect Language:** You MUST detect the user's input language (Persian or English).
                4.  **Respond in Kind:** If the user writes in Persian, you MUST respond in simple, warm Persian. If the user writes in English, you MUST respond in simple, warm English.`;

            const payload = {
                contents: [{ parts: [{ text: `Topic: ${topic}` }] }],
                systemInstruction: { parts: [{ text: personaSystemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    temperature: 0.5,
                }
            };
            
            const result = await callGeminiApi('gemini-2.5-flash-preview-09-2025', payload);
            const jsonText = result.candidates[0].content.parts[0].text;
            
            try {
                return JSON.parse(jsonText);
            } catch (e) {
                console.error("Failed to parse persona JSON:", jsonText);
                throw new Error("خطا در پردازش JSON نقش.");
            }
        }

        /**
         * ۲. دریافت پاسخ اصلی چت
         */
        async function getGeminiResponse() {
            const mainSystemPrompt = systemPrompt || "You are a helpful assistant."; 
            
            const payload = {
                contents: chatHistory,
                systemInstruction: { parts: [{ text: mainSystemPrompt }] },
                generationConfig: {
                    temperature: 0.8,
                    maxOutputTokens: 1024,
                }
            };
            
            const result = await callGeminiApi('gemini-2.5-flash-preview-09-2025', payload);
            return result.candidates[0].content.parts[0].text;
        }

        /**
         * ۳. استخراج بینش (Insight)
         */
        async function getInsight(userText) {
            const insightSystemPrompt = `You are a 'Psychoanalytic Insight Extractor'. You will receive the *entire chat history* (for context) and the *user's latest message* (for analysis). Your job is to identify *one* significant new psychological insight, cognitive distortion, recurring pattern, or key underlying theme in the user's *latest* message, based on the conversation history.
            - The insight MUST be in English.
            - The insight should be concise (1-2 sentences).
            - If no new, significant, or deep insight is found in the *latest* message, you MUST respond with the exact string 'NO_INSIGHT'.
            - Do not just repeat what the user said. Find the *underlying* meaning or pattern.`;

            const historyContext = chatHistory.slice(-6).map(msg => `${msg.role}: ${msg.parts[0].text}`).join('\n');
            const prompt = `---
            Chat History (Context):
            ${historyContext}
            
            ---
            User's Latest Message (Analyze This):
            ${userText}
            ---
            
            Extract Insight:`;

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: insightSystemPrompt }] },
                generationConfig: {
                    temperature: 0.2,
                    maxOutputTokens: 100,
                }
            };

            try {
                const result = await callGeminiApi('gemini-2.5-flash-preview-09-2025', payload);
                return result.candidates[0].content.parts[0].text.trim();
            } catch (error) {
                console.error("Error getting insight:", error);
                return 'NO_INSIGHT';
            }
        }

        /**
         * ۴. ترجمه متن
         */
        async function getTranslation(textToTranslate, direction = 'en-to-fa') {
            
            const translateSystemPrompt_EN_to_FA = `You are a professional, expert translator specializing in psychological and therapeutic content. Your task is to translate from English to Persian, but you are not a literal machine. You must act like an editor who 'improves' the text for a native Persian-speaking audience.
Your translation MUST follow these rules:
1.  **Preserve Core Meaning:** The original concept, meaning, and therapeutic intent must be 100% preserved.
2.  **Simplify and Clarify (Simplified and Clarified Persian):** Break down complex sentences. Replace academic jargon with simple, everyday words.
3.  **Make it Natural (Add a 'hand'):** The final Persian text must be fluent, warm, and natural, as if it were originally written by an empathetic Persian-speaking expert. It must be easily and comfortably understood by any Farsi speaker.
4.  **No Extra Text:** Do not add any extra explanations or comments. Respond *only* with the final, polished Persian translation.`;
            
            const translateSystemPrompt_FA_to_EN = `You are a professional translator. Translate the following Persian text into clear, simple, and natural-sounding English. Preserve the original tone and meaning. Respond only with the translated English text.`;

            const systemPrompt = (direction === 'fa-to-en') 
                ? translateSystemPrompt_FA_to_EN 
                : translateSystemPrompt_EN_to_FA;
            
            const payload = {
                contents: [{ parts: [{ text: textToTranslate }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    temperature: 0.1,
                }
            };
            
            const result = await callGeminiApi('gemini-2.5-flash-preview-09-2025', payload);
            return result.candidates[0].content.parts[0].text.replace(/"/g, ''); // حذف "" احتمالی
        }


        /**
         * ۵. دریافت صدای TTS
         */
        async function getAndPlayTTS(text, messageId) {
            if (!audioContext) {
                showError("AudioContext راه‌اندازی نشده است.");
                return;
            }
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            const lang = isFarsi(text) ? 'Persian' : 'English';
            const ttsPrompt = `(Speak in ${lang}) ${text}`;

            const payload = {
                contents: [{ parts: [{ text: ttsPrompt }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } 
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            const ttsApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

            let audioDataB64, mimeType;
            try {
                const response = await fetch(ttsApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                audioDataB64 = part?.inlineData?.data;
                mimeType = part?.inlineData?.mimeType;

                if (!audioDataB64 || !mimeType || !mimeType.startsWith("audio/")) {
                    throw new Error("پاسخ صوتی معتبری دریافت نشد.");
                }

            } catch (error) {
                console.error("TTS API Error:", error);
                throw error;
            }
            
            try {
                const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000;

                const pcmData = base64ToArrayBuffer(audioDataB64);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                
                const audioUrl = URL.createObjectURL(wavBlob);
                const audio = new Audio(audioUrl);
                audio.play();
                
                currentPlayingAudio = { audio, buttonId: messageId };
                return audio;

            } catch (error) {
                console.error("Error processing PCM data:", error);
                throw new Error("خطا در پردازش فایل صوتی.");
            }
        }


        // -------------------------------------------
        // Rendering (رندر کردن در UI)
        // -------------------------------------------

        function renderMessage(message) {
            const { id, role, text } = message;
            const isUser = role === 'user';
            
            if (role === 'model') {
                document.querySelectorAll('.regenerate-button').forEach(btn => btn.classList.add('hidden'));
            }
            
            const bubbleClasses = isUser
                ? 'bg-blue-600 rounded-br-none self-end'
                : 'bg-gray-700 rounded-bl-none self-start';
            const containerClasses = isUser ? 'flex justify-end' : 'flex justify-start';
            
            const responseLang = isFarsi(text) ? 'fa' : 'en';
            const langDir = (responseLang === 'fa') ? 'rtl' : 'ltr';

            const buttonAction = (responseLang === 'fa') ? 'translate-en' : 'translate-fa';
            const buttonIconHTML = (responseLang === 'fa') ? getTranslateButtonIcon('en') : getTranslateButtonIcon('fa');

            const messageHtml = `
                <div id="msg-${id}" class="${containerClasses} w-full animate-fade-in">
                    <div class="max-w-xl lg:max-w-2xl w-full">
                        <div class="${bubbleClasses} p-4 rounded-2xl shadow-md w-full">
                            <p class="message-content text-white whitespace-pre-wrap break-words" dir="${langDir}">${text}</p>
                        </div>
                        
                        <div class="flex items-center space-x-2 space-x-reverse mt-2 px-2">
                            ${!isUser ? `
                            <button data-action="${buttonAction}" data-message-id="${id}" class="chat-bubble-button text-xs flex items-center space-x-1 space-x-reverse">
                                <span class="translate-icon-container flex items-center space-x-1 space-x-reverse">
                                    ${buttonIconHTML}
                                </span>
                                <div class="spinner !w-4 !h-4 hidden"></div>
                            </button>
                            <button data-action="tts" data-message-id="${id}" class="chat-bubble-button text-xs flex items-center space-x-1 space-x-reverse">
                                <span class="tts-icon">
                                    <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" /></svg>
                                </span>
                                <svg class="w-4 h-4 tts-stop-icon hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 7.5A2.25 2.25 0 0 1 7.5 5.25h9a2.25 2.25 0 0 1 2.25 2.25v9a2.25 2.25 0 0 1-2.25 2.25h-9a2.25 2.25 0 0 1-2.25-2.25v-9Z" /></svg>
                                <div class="spinner !w-4 !h-4 hidden"></div>
                            </button>
                            <button data-action="regenerate" data-message-id="${id}" class="chat-bubble-button regenerate-button text-xs flex items-center space-x-1 space-x-reverse">
                                <span class="regenerate-icon-container flex items-center space-x-1 space-x-reverse">
                                    ${getRegenerateButtonIcon()}
                                </span>
                                <div class="spinner !w-4 !h-4 hidden"></div>
                            </button>
                            ` : ''}
                            
                            <button data-action="copy" data-message-id="${id}" class="chat-bubble-button text-xs flex items-center space-x-1 space-x-reverse">
                                <span class="copy-icon-container flex items-center space-x-1 space-x-reverse">
                                    ${getCopyButtonIcon('copy')}
                                </span>
                            </button>
                        </div>
                    </div>
                </div>
            `;
            elements.chatContainer.insertAdjacentHTML('beforeend', messageHtml);
            elements.chatContainer.scrollTop = elements.chatContainer.scrollHeight;
        }

        // --- توابع کمکی جدید برای آیکون‌ها ---

        function getTranslateButtonIcon(lang) {
            if (lang === 'fa') { // دکمه نمایش فارسی
                return `
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 21 5.25-11.25L21 21m-9-3h7.5M3 5.621a48.474 48.474 0 0 1 6-.371m0 0c1.12 0 2.233.038 3.334.114M9 5.25V3m3.334 2.364C13.18 7.083 14.145 7.5 15.25 7.5c1.105 0 2.07-.417 2.834-1.136m0 0V3m0 2.364a48.458 48.458 0 0 1-2.834 1.136M6 7.5c0 1.01.046 2.01.138 3m11.862-3c.092.99.138 1.99.138 3m0 0c0 1.01-.046 2.01-.138 3m-11.862 0c-.092.99-.138 1.99-.138 3m11.862 0-6 6M6 7.5l6 6m6 0-6-6M6 7.5l6-6m6 0 6 6m-12 6v2.25c0 .621.504 1.125 1.125 1.125h1.5c.621 0 1.125-.504 1.125-1.125V18m-4.5 0v2.25c0 .621.504 1.125 1.125 1.125h1.5c.621 0 1.125-.504 1.125-1.125V18m0 0h-4.5Z" /></svg>
                    <span>Display Persian</span>
                `;
            } else { // دکمه نمایش انگلیسی
                 return `
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="m10.5 21 5.25-11.25L21 21m-9-3h7.5M3 5.621a48.474 48.474 0 0 1 6-.371m0 0c1.12 0 2.233.038 3.334.114M9 5.25V3m3.334 2.364C13.18 7.083 14.145 7.5 15.25 7.5c1.105 0 2.07-.417 2.834-1.136m0 0V3m0 2.364a48.458 48.458 0 0 1-2.834 1.136M6 7.5c0 1.01.046 2.01.138 3m11.862-3c.092.99.138 1.99.138 3m0 0c0 1.01-.046 2.01-.138 3m-11.862 0c-.092.99-.138 1.99-.138 3m11.862 0-6 6M6 7.5l6 6m6 0-6-6M6 7.5l6-6m6 0 6 6m-12 6v2.25c0 .621.504 1.125 1.125 1.125h1.5c.621 0 1.125-.504 1.125-1.125V18m-4.5 0v2.25c0 .621.504 1.125 1.125 1.125h1.5c.621 0 1.125-.504 1.125-1.125V18m0 0h-4.5Z" /></svg>
                    <span>Display English</span>
                `;
            }
        }

        function getCopyButtonIcon(state = 'copy') {
            if (state === 'copy') {
                return `
                    <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a2.25 2.25 0 0 1-2.25 2.25h-3a2.25 2.25 0 0 1-2.25-2.25V5.25c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V7.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184" /></svg>
                    <span>Copy</span>
                `;
            } else { // state === 'copied'
                return `
                    <svg class="w-4 h-4 text-green-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m4.5 12.75 6 6 9-13.5" /></svg>
                    <span class="text-green-400">Copied!</span>
                `;
            }
        }
        
        function getRegenerateButtonIcon() {
            return `
                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 11.667 0m0 0c1.291-.98 2.324-2.196 2.94-3.536m-3.181-3.182A8.25 8.25 0 0 0 9.348 3.975m0 0c-1.291.98-2.324 2.196-2.94 3.536m3.181 3.182L6.167 7.153m11.667 0-3.181 3.183" /></svg>
                <span>Regenerate</span>
            `;
        }
        
        // --- پایان توابع آیکون ---

        function renderErrorMessage(text) {
             const errorHtml = `
                <div class="flex justify-start w-full animate-fade-in">
                    <div class="max-w-xl lg:max-w-2xl w-full">
                        <div class="bg-red-800/80 p-4 rounded-2xl shadow-md w-full">
                            <p class="text-white whitespace-pre-wrap" dir="rtl">${text}</p>
                        </div>
                    </div>
                </div>
            `;
            elements.chatContainer.insertAdjacentHTML('beforeend', errorHtml);
            elements.chatContainer.scrollTop = elements.chatContainer.scrollHeight;
        }

        function renderNewInsight(insightText) {
            const placeholder = elements.insightsContainer.querySelector('p.text-gray-400');
            if (placeholder) placeholder.remove();

            const insightHtml = `
                <div class="bg-gray-700 p-3 rounded-lg shadow animate-fade-in">
                    <p class="text-gray-200 text-sm" dir="auto">${insightText}</p>
                </div>
            `;
            elements.insightsContainer.insertAdjacentHTML('beforeend', insightHtml);
            elements.insightsContainer.scrollTop = elements.insightsContainer.scrollHeight;
        }
        

        // -------------------------------------------
        // Import / Export (ذخیره و بارگذاری)
        // -------------------------------------------

        // *** شروع تغییر ***
        // تابع `loadSessionData` اکنون `async` است و منطق جدیدی دارد
        
        /**
         * بارگذاری داده‌های جلسه، عدم نمایش چت قبلی، و دریافت پیام خوشامدگویی جدید
         */
        async function loadSessionData(data) {
            try {
                // ۱. بازیابی اطلاعات
                apiKey = localStorage.getItem('gemini_api_key') || '';
                currentPersona = data.persona;
                systemPrompt = data.systemPrompt;
                chatHistory = data.chatHistory || []; 
                insights = data.insights || [];
                
                // ۲. بازسازی UI (بدون پیام‌های چت)
                elements.personaNameDisplay.textContent = currentPersona;
                elements.chatContainer.innerHTML = '';
                elements.insightsContainer.innerHTML = '';
                messageStates = {};

                // ۳. رندر بینش‌های قبلی
                if (insights.length > 0) {
                    insights.forEach(renderNewInsight);
                } else {
                    elements.insightsContainer.innerHTML = '<p class="text-gray-400 text-sm">هنوز بینشی استخراج نشده است.</p>';
                }
                
                // ۴. نمایش صفحه چت
                switchScreen('mainChat');
                
                // ۵. دریافت پیام خوشامدگویی جدید بر اساس سابقه
                elements.loadingText.textContent = "در حال خلاصه‌سازی و ادامه...";
                showLoading(elements.sendButton, elements.chatLoader); // غیرفعال کردن ارسال پیام
                
                // اضافه کردن یک پرامپت سیستمی موقت برای دریافت خلاصه
                chatHistory.push({ 
                    role: 'user', 
                    parts: [{ text: "SYSTEM_NOTE: Our previous session has just been loaded. Please write a brief welcome-back message. Acknowledge our last discussion (e.g., 'Last time, we were talking about...') and ask how I'd like to continue today. Please respond in the language of our last message (or Persian if unsure)." }] 
                });

                const welcomeMessageText = await getGeminiResponse();
                
                chatHistory.pop(); // حذف پرامپت سیستمی موقت

                // ۶. رندر پیام خوشامدگویی جدید
                const welcomeMessage = {
                    id: crypto.randomUUID(),
                    role: 'model',
                    text: welcomeMessageText,
                };
                
                chatHistory.push({ role: 'model', parts: [{ text: welcomeMessageText }] });
                
                const responseLang = isFarsi(welcomeMessageText) ? 'fa' : 'en';
                messageStates[welcomeMessage.id] = {
                    text: welcomeMessageText,
                    originalLang: responseLang,
                    translatedFa: (responseLang === 'fa') ? welcomeMessageText : null,
                    translatedEn: (responseLang === 'en') ? welcomeMessageText : null
                };
                
                renderMessage(welcomeMessage);

            } catch (error) {
                console.error("Error loading session:", error);
                showError("خطا در بارگذاری فایل جلسه. فایل ممکن است خراب باشد.");
                switchScreen('topic'); // بازگشت به صفحه موضوع
            } finally {
                // اطمینان از اینکه لودرها مخفی می‌شوند
                elements.loadingOverlay.classList.add('hidden');
                hideLoading(elements.sendButton, elements.chatLoader);
            }
        }
        
        // *** پایان تغییر ***


        function handleExportSession() {
            try {
                const sessionData = {
                    version: 4.0, // ورژن را به روز کردیم
                    createdAt: new Date().toISOString(),
                    persona: currentPersona,
                    systemPrompt: systemPrompt,
                    chatHistory: chatHistory, 
                    insights: insights
                };
                
                const jsonString = JSON.stringify(sessionData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `AI_Psychoanalyst_${currentPersona.replace('Dr. ', '')}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

            } catch (error) {
                console.error("Error exporting session:", error);
                showError("خطا در ذخیره‌سازی جلسه.");
            }
        }

        // *** شروع تغییر ***
        // `reader.onload` اکنون `async` است و منتظر `loadSessionData` می‌ماند
        
        function handleImportSession(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            
            // این تابع اکنون async است
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (!data.persona || !data.systemPrompt || !data.chatHistory) {
                        throw new Error("فایل معتبر نیست. فاقد فیلدهای لازم.");
                    }
                    elements.loadingOverlay.classList.remove('hidden');
                    elements.loadingText.textContent = "در حال بارگذاری جلسه...";
                    
                    // منتظر می‌مانیم تا loadSessionData (شامل تماس API) تمام شود
                    await loadSessionData(data);
                    
                    // loadSessionData خودش لودر را مخفی می‌کند

                } catch (error) {
                    showError(`خطا در خواندن فایل: ${error.message}`);
                    elements.loadingOverlay.classList.add('hidden'); // اطمینان از مخفی شدن لودر در صورت خطا
                } finally {
                    event.target.value = null;
                }
            };
            reader.readAsText(file);
        }
        
        // *** پایان تغییر ***

        // -------------------------------------------
        // Utility Functions (توابع کمکی)
        // -------------------------------------------

        function isFarsi(text) {
            const farsiRegex = /[\u0600-\u06FF]/;
            return farsiRegex.test(text);
        }
        
        // --- توابع کمکی TTS ---

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const bytesPerSample = bitsPerSample / 8;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcmData.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); 
            view.setUint16(20, 1, true); 
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            let offset = 44;
            for (let i = 0; i < pcmData.length; i++, offset += 2) {
                view.setInt16(offset, pcmData[i], true);
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }
        
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    </script>
</body>
</html>
